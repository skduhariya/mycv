(function() {
  'use strict';

  angular.module('public').service('myCvService', myCvService);

  myCvService.$inject = ['$q', '$filter', '$sce'];

  function myCvService($q, $filter, $sce) {
   //    console.log("service ... ");

   var service = this;
   var projectList = [];
   var blogList = [];

   projectList.push({
    shortName: "Customer-Portal",
    name: "Customer Portal",
    img: "images/1.jpg",
    client: "3M India",
    shortDesc: "Sales Portal Application, Developed for 3m India",
    dur: "9 months",
    description: "The System Entitled Sales Portal Application is Application Software which is Developed for 3m India, which aims at the development of Sales Order Generation and it is developed using J2EE Technology. For this we have used different tools of like front page as a front end  Jsp  and Bootstrap for developing web pages, database created by As400 and Sql Server , we have used Angular Is, Spring, JDBC Template ,HTML. This application is developed to have a Track of Sales Which is generated by 3m India, From the time Order Gets generated to till the full Invoice Received the system gets a track of all the things. This Application Works for various profile to login (like sales, customer, finance) to have a track of the Order. It can run in any Platform.",
    technologies: {
     frontEnd: "HTML5, CSS3, JavaScript, AngularJS, jQuery, Bootstrap 3.0",
     backEnd: "Core Java, J2EE, Spring Framework, JDBC Template",
     database: "AS400 admin, SQL"
    },
    responsibility: {
     res1: "Developed an application with responsive view for user.",
     res2: "Design and development of angular UI-Routing.",
     res3: "Development of dynamic menu.",
     res4: "Design and development of role based work flow of the project.",
     res5: "Responsible for writing a DAO layer and SERVICE layer coding."
    },
     url:$sce.trustAsResourceUrl('')

   });
   projectList.push({
    shortName: "GKSL-Academic",
    name: "GKSL Academic",
    img: 'images/2.jpg',
    client: "GKSL India Bangalore",
    shortDesc: "Complete Education Solutions for Corporation",
    dur: "5 months",
    description: "This application was developed by using Cordova. This app mainly comprises of providing complete education solutions for corporations and government organizations that need to train their staff on the latest business skills and Information Technology tools, methodologies and languages. Users can test their skills by giving mock tests provided by the app and this app works in offline also.",
    technologies: {
     frontEnd: "HTML5, CSS3, JavaScript, AngularJS, jQuery, Bootstrap 3.0",
     backEnd: "Cordova API",
     database: "SQL Lite"
    },
    responsibility: {
     res1: "Co-ordinated with the client and documented all the requirements regarding the project.",
     res2: "Worked on Design part",
     res3: "Worked on many Cordova API,s to access native features of Phone",
     res4: "",
     res5: ""
    },
     url:$sce.trustAsResourceUrl('')


   });
   projectList.push({
    shortName: "GlobalKnowledge-tech",
    name: "Global Knowledge Tech",
    img: 'images/4.jpg',
    client: "Global Knowledge",
    shortDesc: "A Training portal that provide a vivid & complete Training about the IBM Technologies",
    dur: "3 months",
    description: "Global Knowledge is the world's leading learning services and professional development solutions provider. Global Knowledge deliver learning solutions to support customers as they adapt to key business transformations and technological advancements that drive the way that organizations around the world differentiate themselves and thrive. Global Knowledge learning programs, whether designed for a global organization or an individual professional, help businesses close skills gaps and foster an environment of continuous talent development.",
    technologies: {
     frontEnd: "HTML5, CSS3, JavaScript, jQuery, Bootstrap 3.0",
     backEnd: "Core Java, J2EE",
     database: "My SQL"
    },
    responsibility: {
     res1: "Co-ordinated with the client and documented all the requirements regarding the project.",
     res2: "Worked on Design part",
     res3: "Design and development of role based work flow of the project.",
     res4: "",
     res5: ""
    },
     url:$sce.trustAsResourceUrl('http://www.globalknowledgetech.com/')

   });
   projectList.push({
    shortName: "JECRC-Portal",
    name: "JECRC Portal",
    img: 'images/3.jpg',
    client: "JECRC Jaipur",
    shortDesc: "A web portal that provide a vivid & complete view about the JECRC Computer Users",
    dur: "5 months",
    description: "This application was developed by using Cordova. This app mainly comprises of providing complete education solutions for corporations and government organizations that need to train their staff on the latest business skills and Information Technology tools, methodologies and languages. Users can test their skills by giving mock tests provided by the app and this app works in offline also.",
    technologies: {
     frontEnd: "HTML5, CSS3, JavaScript, jQuery, Bootstrap 3.0",
     backEnd: "Core Java, J2EE",
     database: "My SQL"
    },
    responsibility: {
     res1: "Co-ordinated with the client and documented all the requirements regarding the project.",
     res2: "Worked on Design part",
     res3: "Design and development of role based work flow of the project.",
     res4: "",
     res5: ""
    },
     url:$sce.trustAsResourceUrl('')

   });
    projectList.push({
    shortName: "eLearning-Portal",
    name: "eLearning Portal",
    img: "images/2.jpg",
    client: "SilverLake Information System Pvt. Ltd.",
    shortDesc: "Training the Corporate Candidates in IBM Tech.",
    dur: "4 months",
    description: "eLearning Portal provides the corporate team to train their candidates by providing online video tutorials,it provides the Corporate Management to know the statistics of the each candidates performance.",
    technologies: {
     frontEnd: "HTML5, CSS3, JavaScript, AngularJS, jQuery, Bootstrap 3.0",
     backEnd: "Core Java, J2EE, Spring Framework, JDBC Template",
     database: "MySQL"
    },
    responsibility: {
     res1: "Developed an application with responsive view for user.",
     res2: "Design and development of angular UI-Routing.",
     res3: "Development of dynamic menu.",
     res4: "Design and development of role based work flow of the project.",
     res5: "Responsible for writing a DAO layer and SERVICE layer coding."
    },
     url: $sce.trustAsResourceUrl('http://elearning.silverlake.co.in/')

   });
   blogList.push({
      shortName: 'JS-Closure',
      date: 'Feb 17, 2017',
      img: 'images/3.jpg',
      topic: 'JS Closure',
      smalInfo: 'Understand JavaScript Closure',
      technology: 'JS',
      ques: 'What is a closure?',
      defination: 'A closure is an inner function that has access to the outer (enclosing) function’s variables - scope chain. The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables.',
      infoPart1: 'A closure is a local variable for a function kept alive after the function has returned, or',
      infoTopic: {
       topics: [{
        name: '',
        points: [{
         info: 'A closure is a stack - frame which is not deallocated. for example'
        }],
        example: [{
         lineno: '1',
         data: 'function sayHello(name){',
        }, {
         lineno: '2',
         data: '  var text = \'Hello \' + name; // local variable',
        }, {
         lineno: '3',
         data: '  var printName = function(){',
        }, {
         lineno: '4',
         data: '    alert(text);',
        }, {
         lineno: '5',
         data: '  }',
        }, {
         lineno: '6',
         data: ' return printName;',
        }, {
         lineno: '7',
         data: '}',
        }, {
         lineno: '8',
         data: ' var say = sayHello(\'sandy\'); say();',
        }]
      }]


    },
    jsfiddle: $sce.trustAsResourceUrl(''),
    points2: [{
     info: 'The above code has a closure because the anonymous function \'function() {alert(text);}\' is declare inside another function, sayHello() in this Example. In javascript, if you use the function keyword inside another function, you are creating a closure.',
    }, {
     info: 'In C, and most other common languages after a function returns, all the local variables are no longer accessible because the stack-frame is destroyed. '
    }, {
     info: 'In JavaScript, if you declare a function within another function, then the local variables can remain accessible after returning from the function you called. This is demonstrated above, because we call the function say(); after we have returned from sayHello(). Notice that the code that we call references the variable text, which was a local variable of the function sayHello().'
    }],
    summary: {
     heading: 'Summary of JavaScript closure',
     points: [{
      point: '1',
      info: 'Whenever you use function inside another function, a closure is used.'
     }, {
      point: '2',
      info: 'When ever you use  eval()  inside function, a closure is used. the text you eval can reference local variables of the function, and within eval you can even create new local variables by using eval(var abc = ....).',
     }, {
      point: '3',
      info: 'When you use Function() inside a function, it does not create a closure. (The new function cannot reference the local variables of the function calling Function()).'
     }, {
      point: '4',
      info: 'A closure in JavaScript is like keeping a copy of the all the local variables, just as they were when a function exited.'
     }, {
      point: '5',
      info: 'It is probably best to think that a closure is always created just on entry to a function, and the local variables are added to that closure.'
     }, {
      point: '6',
      info: 'If you are trying to do any dynamic source code modifications ( for example: myFunction = Function(myFunction.toString().replace(/Hello/,\'Hola\')); ), it won\'t work if myFunction is a closure (Of course, you would never even think of doing source code string substitution at runtime, but...).'
     }, {
      point: '7',
      info: 'It is possible to get function declarations within function declarations within functions - and you can get closures at more than one level.'
     }]
    }
  }); blogList.push({
  shortName: 'Angular-modules',
  date: 'Feb 20, 2017',
  img: 'images/1.jpg',
  topic: 'Angular JS Service vs Factory vs Provider',
  smalInfo: 'Dependency Injection - angularJs',
  technology: 'AngularJs',
  ques: 'Angular JS Service vs Factory vs Provider',
  defination: 'In angularjs the controller should not contain much, if any business logic functionality itself. Instead, it should pass on the responsibility of handling business logic to some other components. these components are Service, Factory and provider.',
  infoPart1: 'AngularJS Service, Factory or Provider all are used for the same purpose of creating utility function that can be used throughout the page with inject-able object. However, the way it is created and the way it is used are different. Here we shall try to understand them clearly.',
  infoTopic: {
   topics: [{
    name: 'Service',
    points: [{
     info: 'The module instance in angular has another method called service. and just like a controller, its take the name of the service and the function of value that is to be the function used to create that service.'
    }, {
     info: 'The Service angularjs will create for us using this method is guaranteed to be a singleton(Restrict object to be always having a single instance).that\'s why services are very convenient for sharing data across our application. '
    }, {
     info: 'There\'s another property of a service that we need to know about and that is lazily Instansiated(Only created if an application component declares it as a dependency). '
    }, {
     info: 'When we are using Service, it\'s instantiated with the \'new\' keyword. Because of that, we will add properties to \'this\' and the service will return \'this\'. When we pass the service into our controller, those properties on ‘this’ will now be available on that controller through our service.'
    }],
    example: [{
     lineno: '1',
     data: 'var app = angular.module("app", []);',
    }, {
     lineno: '2',
     data: 'app.controller("serviceCtrl",serviceCtrl);',
    }, {
     lineno: '3',
     data: 'function serviceCtrl($scope, myService){// service function call',
    }, {
     lineno: '4',
     data: ' $scope.ServiceOutput = "Service Output";',
    }, {
     lineno: '5',
     data: ' $scope.HelloService = function () {',
    }, {
     lineno: '6',
     data: ' $scope.ServiceOutput = myService.sayHello(\'Sandy\');',
    }, {
     lineno: '7',
     data: ' };',
    }, {
     lineno: '8',
     data: ' }',
    }, {
     lineno: '9',
     data: 'app.service("myService", myService); // create utility function with service',
    }, {
     lineno: '10',
     data: 'function myService() {  // service function on this object',
    }, {
     lineno: '11',
     data: 'this.sayHello = function (name) {',
    }, {
     lineno: '12',
     data: 'return "Hello "+name;',
    }, {
     lineno: '13',
     data: '};',
    }, {
     lineno: '14',
     data: '};',
    }]

   }, {
    name: 'Factory',
    points: [{
     info: 'Factory Design pattern characteristic is basically that it\'s a central that produces new objects or functions. now, this is not an official defination of the factory design pattern. but I think it communicates the idea without too much of the computer science-y lingo.'
    }, {
     info: 'The purpose of Factory is also same as Service however in this case we create a new object and add functions as properties of this object and at the end we return this object.'
    }, {
     info: 'When we pass this service into our controller, those properties on the object will now be available in that controller through our factory.'
    }, {
     info: 'Now the way we register the service factory function is very similar to the way we registered the service and the controller. We coded that factory method on the module. We specify the name of our factory, myFactory.'
    }, {
     info: 'note the very big difference. if we made the same exact call within that service method, the custom service would be expected to be the service, not produce a service as a result of either direct invocation, or invocation of one of its methods. '
    }, {
     info: 'For factory we need to create .factory method. Here, we have created function "sayHello" on the new object "factoryObject" created and then we are returning that object at the end of the factory method.'
    }],
    example: [{
     lineno: '1',
     data: 'app.controller("factoryCtrl",factoryCtrl);',
    }, {
     lineno: '2',
     data: 'function factoryCtrl($scope, myFactory){// factory function call',
    }, {
     lineno: '3',
     data: '$scope.FactoryOutput = "Factory Output";',
    }, {
     lineno: '4',
     data: '$scope.HelloFactory = function () {',
    }, {
     lineno: '5',
     data: ' $scope.FactoryOutput = myFactory.sayHello(\'Sandy\');',
    }, {
     lineno: '6',
     data: ' };',
    }, {
     lineno: '7',
     data: ' };',
    }, {
     lineno: '8',
     data: ' // create utility function with factory',
    }, {
     lineno: '9',
     data: ' app.factory("myFactory", myFactory);',
    }, {
     lineno: '10',
     data: 'function myFactory() {  // here we return the object',
    }, {
     lineno: '11',
     data: 'var factoryObject = {};',
    }, {
     lineno: '12',
     data: 'factoryObject.sayHello = function (name) {',
    }, {
     lineno: '13',
     data: 'return "Hello "+name;',
    }, {
     lineno: '14',
     data: '}',
    }, {
     lineno: '15',
     data: 'return factoryObject;',
    }, {
     lineno: '16',
     data: '};',
    }]

   }, {
    name: 'Provider',
    points: [{
     info: 'The .provider method is the most verbose, and at the same time, the most flexible method of creating services in Angular. Not only you can create a factory that\'s dynamically configurable at the time of using the factory, with the provider method, you could custom configure the factor just once at the bootstraping of your entire application. and then use that factory throughout your application with your custom settings.'
    }, {
     info: 'In other words, you could configure this factory before your application starts.In fact, as the angular documentation tells us, the provider method is what acually gets executed behind the scenes when we configure our services with either .service or .factory methods.'
    }, {
     info: 'The provider method has a special function $get that has a perticular property on the actual instance of the function. $get is a function that is directly attached to the provider instance. That function is a factory function. In others words it\'s just like the one that  we use to provide to the .factory method.'
    }, {
     info: 'Providers are the only service you can pass into your .config() function. Use a provider when you want to provide module-wide configuration for your service object before making it available.'
    }, {
     info: '.config function is a special function that you can invoke on the module instance that is guaranteed to run before any services, factories, or controller are even created. Which means that\'s a step for us to be able to tap into configure these services before they are ever created.'
    }, {
     info: 'let\'s see bellow example, we have created a provider using .provider method in which we are returning an object having function "sayHello" to the $get function.'
    }],
    example: [{
     lineno: '1',
     data: 'app.controller("providerCtrl",providerCtrl);',
    }, {
     lineno: '2',
     data: 'function providerCtrl($scope, myProvider){// provider function call',
    }, {
     lineno: '3',
     data: '$scope.ProviderOutput = "Provider Output";',
    }, {
     lineno: '4',
     data: '$scope.HelloProvider = function () {',
    }, {
     lineno: '5',
     data: ' $scope.ProviderOutput = myProvider.sayHello(\'Sandy\');',
    }, {
     lineno: '6',
     data: ' };',
    }, {
     lineno: '7',
     data: ' };',
    }, {
     lineno: '8',
     data: ' // create utlity function with provider',
    }, {
     lineno: '9',
     data: ' app.provider("myProvider", myProvider);',
    }, {
     lineno: '10',
     data: 'function myProvider() {',
    }, {
     lineno: '11',
     data: 'this.$get = function () {',
    }, {
     lineno: '12',
     data: 'return {',
    }, {
     lineno: '13',
     data: ' sayHello: function (name) {',
    }, {
     lineno: '14',
     data: 'return "Hello "+ name;',
    }, {
     lineno: '15',
     data: '}',
    }, {
     lineno: '16',
     data: '};',
    }, {
     lineno: '17',
     data: '};',
    }, {
     lineno: '18',
     data: '};',
    }]

   }]


  },
  jsfiddle: $sce.trustAsResourceUrl('https://jsfiddle.net/skduhariya/dpm8wc22/2/embedded/js,html,css,result/dark/'),
  points2: [{
   info: 'Notice that all three have the same function "sayHello" having same functionality but the way of declaration is different. This is the major difference between Service, Factory and Provider.',
  }],
  summary: {
   heading: 'Summary',
   points: [{
    point: '1',
    info: 'Angularjs service instantiated with .service method are singleton which means there\'s only one instance of the object that ever exists.'
   }, {
    point: '2',
    info: 'Angular service is also, service instantiated with a .service method  are lazily instantiated, which means they\'re only created if something acually depends on them. if nothing depends on them they\'re simply not instantiated at all.',
   }, {
    point: '3',
    info: '.service(\'name\', function), treats function as a function constructor, that what it means is that the angular JS internally will actually new up your function using in new keyword Which has ramifications for what this keyword means inside of your service function.'
   }, {
    point: '4',
    info: 'The .factory() function allows us to produce any type of object or function. That includes a service in even a singleton, but it\'s not limited to that. '
   }, {
    point: '5',
    info: ' The .service on the other hand, is just a more limited factory. It limits us to creating a service that is a singleton and also one that\'s very hard to custom configure. '
   }, {
    point: '6',
    info: 'The way you invoked the .factory method is very similarly to the way invoked the .service or really .controller method. You give it a name and a FactoryFunction. The name you give to your factory is what gets injected into other components. '
   }, {
    point: '7',
    info: ' the .service() method is also called a factory, but a much more limited one compared to the .factory() method. The service method is a factory that always produces the same type of service, a singleton and without an easy way to configure its behaviour. That .service() method is usually used as a shortcut for something that doesn\'t require any configuration whatsoever.'
   }, {
    point: '8',
    info: 'The injected factory function refers to whatever is returned in the factory function. It can be an object literal with a property with a property that\'s a function that creates something for us. It can also directly be a function that itself, creates something for us. '
   }, {
    point: '9',
    info: 'The $get property that\'s a function, is what makes the provider a provider a provider.'
   }, {
    point: '10',
    info: '.provider() - most verbose, but most flexible.'
   }, {
    point: '11',
    info: 'configure factory not just at time of use, but at app bootstraping. '
   }, {
    point: '12',
    info: '.provider(\'name\', function), what ever the \'name\' is - that\'s what gets injected into other components'
   }, {
    point: '13',
    info: '.config() function gets called before any service, factory, or controller is intansiated. therfor we can\'t inject any regular components into .config. We CAN inject the provider of service with nameProvider.'
   }]
  }
 });

 service.getProjectList = function() {
  var deferred = $q.defer();
  deferred.resolve(projectList);

  return deferred.promise;
 }; service.getProjectDetails = function(pname) {
  var deferred = $q.defer();
  var result = $filter('filter')(projectList, {
   shortName: pname
  });
  //  console.log("Resulltt : >> " + JSON.stringify(result));

  return result;

 };

 service.getBlogList = function() {

  var deferred = $q.defer();
  deferred.resolve(blogList);

  return deferred.promise;

 }; service.getblogsDetails = function(bname) {
  var deferred = $q.defer();
  //    console.log("bname: " + bname);
  //  console.log("c: " + JSON.stringify(projectList));
  //  console.log("blogList[0].shortName: " + blogList[0].shortName);
  //  console.log("result: " + blogList[0].shortName == bname);

  var result = $filter('filter')(blogList, {
   shortName: bname
  });
  //  console.log("Resulltt blog : >> " + JSON.stringify(result));

  return result;
 };
}
})();
